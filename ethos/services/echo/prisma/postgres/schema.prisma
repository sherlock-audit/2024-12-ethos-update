generator client {
  provider        = "prisma-client-js"
  output          = "../../../../node_modules/@prisma-pg/client"
  // Make sure to generate Prisma client for Alpine correctly
  binaryTargets   = ["native", "linux-musl-openssl-3.0.x"]
  previewFeatures = ["metrics", "relationJoins", "views"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Profile {
  id                 Int                  @id
  archived           Boolean              @default(false)
  createdAt          DateTime
  updatedAt          DateTime             @updatedAt
  invitesSent        String[]
  invitesAcceptedIds Int[]
  invitesAvailable   Int
  invitedBy          Int
  ProfileEvent       ProfileEvent[]
  Vouch              Vouch[]
  ProfileAddress     ProfileAddress[]
  Attestation        Attestation[]
  SentInvitations    Invitation[]         @relation("sent")
  Invitation         Invitation[]
  ReputationMarket   Market?
  ContributionBundle ContributionBundle[]
  UserFcmToken       UserFcmToken[]
  Rewards            Rewards[]

  @@index([archived])
  @@map("profiles")
}

model ProfileAddress {
  id        Int     @id @default(autoincrement())
  profileId Int
  profile   Profile @relation(fields: [profileId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  address   String  @unique @db.Citext // case insensitive

  @@index([profileId])
  @@map("profile_addresses")
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  DECLINED
}

enum Contract {
  PROFILE     @map("profile")
  VOUCH       @map("vouch")
  REVIEW      @map("review")
  ATTESTATION @map("attestation")
  DISCUSSION  @map("discussion")
}

model Invitation {
  id                Int              @id @default(autoincrement())
  senderProfileId   Int
  sender            Profile          @relation("sent", fields: [senderProfileId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  recipient         String           @db.VarChar(42)
  sentAt            DateTime
  acceptedProfileId Int?
  acceptedProfile   Profile?         @relation(fields: [acceptedProfileId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  status            InvitationStatus @default(PENDING)
  statusUpdatedAt   DateTime?

  @@index([senderProfileId, status])
  @@index([acceptedProfileId])
  @@index([recipient])
  @@map("invitations")
}

model Review {
  id                      Int                       @id
  archived                Boolean
  author                  String                    @db.VarChar(42)
  authorProfileId         Int
  subject                 String                    @db.VarChar(42)
  score                   Int
  comment                 String
  metadata                String
  createdAt               DateTime
  updatedAt               DateTime                  @updatedAt
  account                 String
  service                 String
  ReviewEvent             ReviewEvent[]
  ContributionReview      ContributionReview[]
  ContributionReviewCheck ContributionReviewCheck[]
  ContributionReviewVote  ContributionReviewVote[]

  @@index([service, account])
  @@index([archived])
  @@index([author])
  @@index([subject, score])
  @@map("reviews")
}

model Vouch {
  id               Int          @id
  archived         Boolean
  unhealthy        Boolean
  authorAddress    String       @db.VarChar(42)
  authorProfileId  Int
  subjectProfileId Int
  subjectProfile   Profile      @relation(fields: [subjectProfileId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  subjectAddress   String?      @db.VarChar(42)
  attestationHash  String?      @db.Char(66)
  deposited        Decimal      @db.Decimal(78, 0)
  staked           Decimal      @db.Decimal(78, 0)
  balance          Decimal      @db.Decimal(78, 0)
  withdrawn        Decimal      @default(0) @db.Decimal(78, 0)
  mutualVouchId    Int?         @unique
  mutualVouch      Vouch?       @relation("mutualVouch", fields: [mutualVouchId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  mutualVouchRef   Vouch?       @relation("mutualVouch") // links to itself for mutual vouch lookups
  comment          String
  metadata         String
  vouchedAt        DateTime
  updatedAt        DateTime     @updatedAt
  unvouchedAt      DateTime?
  unhealthyAt      DateTime?
  VouchEvent       VouchEvent[]

  @@index([archived])
  @@index([authorProfileId])
  @@index([subjectProfileId])
  @@index([subjectAddress])
  @@index([attestationHash])
  @@map("vouches")
}

model Rewards {
  id        Int      @id @default(autoincrement())
  profileId Int
  profile   Profile  @relation(fields: [profileId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  balance   Decimal  @db.Decimal(78, 0)
  lifetime  Decimal  @db.Decimal(78, 0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([profileId])
  @@index([createdAt])
  @@map("rewards")
}

model Reply {
  id                      Int          @id
  parentId                Int
  targetContract          String       @db.VarChar(42)
  authorProfileId         Int
  createdAt               DateTime
  updatedAt               DateTime     @updatedAt
  content                 String
  metadata                String
  parentIsOriginalComment Boolean
  contract                Contract?
  ReplyEvent              ReplyEvent[]

  @@index([targetContract, parentId])
  @@index([contract, parentId])
  @@map("replies")
}

model Vote {
  id                     Int                      @id
  isUpvote               Boolean
  isArchived             Boolean
  voter                  Int
  targetContract         String                   @db.VarChar(42)
  targetId               Int
  createdAt              DateTime
  updatedAt              DateTime                 @updatedAt
  contract               Contract?
  VoteEvent              VoteEvent[]
  ContributionReviewVote ContributionReviewVote[]

  @@index([voter])
  @@index([targetContract, targetId, isArchived])
  @@index([targetId, isUpvote])
  @@index([contract, targetId])
  @@map("votes")
}

model Attestation {
  id               Int                @id
  hash             String             @unique
  archived         Boolean
  evidence         String
  profileId        Int
  profile          Profile            @relation(fields: [profileId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  createdAt        DateTime
  updatedAt        DateTime           @updatedAt
  account          String
  service          String
  AttestationEvent AttestationEvent[]

  @@index([profileId])
  @@index([service, account, archived])
  @@map("attestations")
}

model BlockchainEvent {
  id               Int                  @id @default(autoincrement())
  contract         String
  logData          Json                 @db.JsonB
  blockNumber      Int
  blockIndex       Int
  createdAt        DateTime
  updatedAt        DateTime             @updatedAt
  txHash           String               @db.Citext
  processed        Boolean              @default(false)
  jobCreated       Boolean              @default(false)
  AttestationEvent AttestationEvent[]
  VoteEvent        VoteEvent[]
  ReplyEvent       ReplyEvent[]
  VouchEvent       VouchEvent[]
  ReviewEvent      ReviewEvent[]
  ProfileEvent     ProfileEvent[]
  MarketEvent      MarketUpdatedEvent[]
  MarketVoteEvent  MarketVoteEvent[]

  @@unique([blockNumber, blockIndex, txHash])
  @@index([contract])
  @@index([txHash])
  @@map("blockchain_events")
}

model BlockchainEventPoll {
  contract        String
  lastBlockNumber Int
  updatedAt       DateTime @updatedAt

  @@unique([contract])
  @@map("blockchain_event_polls")
}

model ProfileEvent {
  eventId   Int
  event     BlockchainEvent   @relation(fields: [eventId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  profileId Int
  profile   Profile           @relation(fields: [profileId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  type      ProfileEventType?

  @@unique([eventId, profileId])
  @@map("profile_events")
}

enum ProfileEventType {
  CREATE   @map("create")
  ARCHIVE  @map("archive")
  RESTORE  @map("restore")
  INVITE   @map("invite")
  UNINVITE @map("uninvite")
}

model ReviewEvent {
  eventId  Int
  event    BlockchainEvent  @relation(fields: [eventId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  reviewId Int
  review   Review           @relation(fields: [reviewId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  type     ReviewEventType?

  @@unique([eventId, reviewId])
  @@map("review_events")
}

enum ReviewEventType {
  CREATE  @map("create")
  EDIT    @map("edit")
  ARCHIVE @map("archive")
  RESTORE @map("restore")
}

model VouchEvent {
  eventId Int
  event   BlockchainEvent @relation(fields: [eventId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  vouchId Int
  vouch   Vouch           @relation(fields: [vouchId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  type    VouchEventType?

  @@unique([eventId, vouchId])
  @@map("vouch_events")
}

enum VouchEventType {
  CREATE           @map("create")
  UNVOUCH          @map("unvouch")
  UNHEALTHY        @map("unhealthy")
  INCREASE         @map("increase")
  DEPOSIT_REWARDS  @map("deposit_rewards")
  WITHDRAW_REWARDS @map("withdraw_rewards")
  SLASH            @map("slash")
}

model ReplyEvent {
  eventId Int
  event   BlockchainEvent @relation(fields: [eventId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  replyId Int
  reply   Reply           @relation(fields: [replyId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  type    ReplyEventType?

  @@unique([eventId, replyId])
  @@map("reply_events")
}

enum ReplyEventType {
  CREATE @map("create")
  EDIT   @map("edit")
}

model AttestationEvent {
  eventId       Int
  event         BlockchainEvent       @relation(fields: [eventId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  attestationId Int
  attestation   Attestation           @relation(fields: [attestationId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  type          AttestationEventType?

  @@unique([eventId, attestationId])
  @@map("attestation_events")
}

enum AttestationEventType {
  CREATE  @map("create")
  ARCHIVE @map("archive")
  RESTORE @map("restore")
  CLAIM   @map("claim")
}

model VoteEvent {
  eventId Int
  event   BlockchainEvent @relation(fields: [eventId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  voteId  Int
  vote    Vote            @relation(fields: [voteId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  type    VoteEventType?

  @@unique([eventId, voteId])
  @@map("vote_events")
}

enum VoteEventType {
  CREATE  @map("create")
  ARCHIVE @map("archive")
  UPDATE  @map("update")
}

model ScoreHistory {
  id                  Int                   @id @default(autoincrement())
  target              String                @db.Citext
  score               Int
  createdAt           DateTime              @default(now())
  txHash              String?               @db.Citext
  dirty               Boolean
  ScoreHistoryElement ScoreHistoryElement[]

  @@index([target, dirty])
  @@index([target, txHash])
  @@index([score])
  @@index([createdAt])
  @@index([target, createdAt(sort: Desc), score(sort: Desc)])
  @@map("score_history")
}

model ScoreHistoryElement {
  scoreHistoryId Int
  scoreHistory   ScoreHistory       @relation(fields: [scoreHistoryId], references: [id])
  scoreElementId Int
  scoreElement   ScoreElementRecord @relation(fields: [scoreElementId], references: [id])

  @@id([scoreHistoryId, scoreElementId])
  @@map("score_history_elements")
}

model ScoreAlgorithm {
  version                Int                      @id @default(autoincrement())
  createdAt              DateTime                 @default(now())
  definition             Json
  ScoreElementDefinition ScoreElementDefinition[]

  @@index([version])
  @@index([createdAt])
  @@map("score_algorithms")
}

model ScoreElementDefinition {
  name                  String
  type                  String
  min                   Int
  max                   Int
  ranges                Json?
  outOfRangeScore       Int?
  scoreAlgorithmVersion Int
  scoreAlgorithm        ScoreAlgorithm       @relation(fields: [scoreAlgorithmVersion], references: [version])
  ScoreElementRecord    ScoreElementRecord[]

  @@unique([name, scoreAlgorithmVersion])
  @@index([scoreAlgorithmVersion])
  @@map("score_element_definitions")
}

model ScoreElementRecord {
  id                     Int                    @id @default(autoincrement())
  name                   String
  version                Int
  raw                    Int
  weighted               Int
  error                  Boolean
  metadata               Json?
  ScoreElementDefinition ScoreElementDefinition @relation(fields: [name, version], references: [name, scoreAlgorithmVersion])
  ScoreHistoryElement    ScoreHistoryElement[]

  @@index([version, name])
  @@map("score_element_records")
}

model EnsCache {
  id        Int      @id @default(autoincrement())
  address   String   @unique @db.Citext // case insensitive
  ensName   String?  @db.Citext // case insensitive
  avatarUrl String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([address])
  @@index([ensName])
  @@map("ens_cache")
}

model TwitterProfileCache {
  id              String    @id
  username        String    @db.Citext // case insensitive
  name            String
  avatar          String?
  biography       String?
  website         String?
  followersCount  Int?
  joinedAt        DateTime?
  isBlueVerified  Boolean?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  attestationHash String    @db.Char(66)

  @@index([username])
  @@index([updatedAt])
  @@index([attestationHash])
  @@map("twitter_profiles_cache")
}

model AddressHistoryCache {
  address          String   @id @db.Citext // case insensitive
  firstTransaction DateTime
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  @@index([address, updatedAt])
  @@map("address_history_cache")
}

model TransactionHistoryCache {
  fromAddress      String   @db.Citext // case insensitive
  toAddress        String   @db.Citext
  hash             String   @unique @db.Citext
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  value            String
  blockNumber      Int
  blockTimestamp   DateTime
  fromAddressLabel String?
  fromAddressLogo  String?
  toAddressLabel   String?
  toAddressLogo    String?
  category         String?
  summary          String?

  @@index([updatedAt, fromAddress])
  @@index([updatedAt, toAddress])
  @@index([fromAddress])
  @@index([toAddress])
  @@index([blockNumber])
  @@map("transaction_history_cache")
}

model Market {
  profileId              Int                  @id
  profile                Profile              @relation(fields: [profileId], references: [id])
  creatorAddress         String               @db.VarChar(42)
  positivePrice          String
  negativePrice          String
  trustVotes             Int
  distrustVotes          Int
  createdAt              DateTime             @default(now())
  updatedAt              DateTime             @updatedAt
  ReputationMarketEvent  MarketUpdatedEvent[]
  MarketVoteEvent        MarketVoteEvent[]
  marketCapWei           String               @default("0")
  volumeTotalWei         String               @default("0")
  volume24hrWei          String               @default("0")
  priceChange24hrPercent Int                  @default(0)
  basePrice              String               @default("0")
  creationCost           String               @default("0")

  @@map("markets")
}

model MarketUpdatedEvent {
  eventId            Int
  event              BlockchainEvent @relation(fields: [eventId], references: [id])
  marketProfileId    Int
  market             Market          @relation(fields: [marketProfileId], references: [profileId])
  createdAt          DateTime        @default(now())
  positivePrice      String
  negativePrice      String
  deltaVoteTrust     Int
  deltaVoteDistrust  Int
  deltaPositivePrice String
  deltaNegativePrice String
  blockNumber        Int

  @@unique([eventId, marketProfileId])
  @@index([marketProfileId, createdAt])
  @@map("market_events")
}

enum MarketVoteEventType {
  BUY
  SELL
}

model MarketVoteEvent {
  eventId         Int
  type            MarketVoteEventType
  actorAddress    String              @db.VarChar(42)
  event           BlockchainEvent     @relation(fields: [eventId], references: [id])
  marketProfileId Int
  market          Market              @relation(fields: [marketProfileId], references: [profileId])
  isPositive      Boolean
  amount          Int
  funds           String
  createdAt       DateTime            @default(now())

  @@unique([eventId, marketProfileId])
  @@index([marketProfileId, createdAt])
  @@index([actorAddress, createdAt])
  @@map("market_vote_events")
}

enum ContributionType {
  REVIEW
  TRUST_BATTLE
  TRUST_CHECK
  REVIEW_CHECK
  REVIEW_VOTE
  SCORE_CHECK
}

enum ContributionStatus {
  PENDING
  COMPLETED
  SKIPPED
}

enum ContributionAnswer {
  POSITIVE
  NEGATIVE
  NEUTRAL
  UNSURE
}

model ContributionBundle {
  id           Int            @id @default(autoincrement())
  profileId    Int
  Profile      Profile        @relation(fields: [profileId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  expireAt     DateTime
  createdAt    DateTime       @default(now())
  Contribution Contribution[]

  @@index([profileId])
  @@map("contribution_bundles")
}

model Contribution {
  id                      Int                      @id @default(autoincrement())
  contributionBundleId    Int
  ContributionBundle      ContributionBundle       @relation(fields: [contributionBundleId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  type                    ContributionType
  experience              Float
  status                  ContributionStatus
  ContributionReview      ContributionReview?
  ContributionTrustBattle ContributionTrustBattle?
  ContributionTrustCheck  ContributionTrustCheck?
  ContributionScoreCheck  ContributionScoreCheck?
  ContributionReviewCheck ContributionReviewCheck?
  ContributionReviewVote  ContributionReviewVote?

  @@index([contributionBundleId])
  @@index([status])
  @@map("contributions")
}

model ContributionTrustCheck {
  contributionId Int                 @id
  Contribution   Contribution        @relation(fields: [contributionId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  targetUserkey  String              @db.Citext
  answer         ContributionAnswer?

  @@map("contribution_trust_checks")
}

model ContributionReview {
  contributionId Int          @id
  Contribution   Contribution @relation(fields: [contributionId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  targetUserkeys String[]
  reviewId       Int?
  review         Review?      @relation(fields: [reviewId], references: [id], onUpdate: Cascade, onDelete: Cascade)

  @@map("contribution_reviews")
}

model ContributionTrustBattle {
  contributionId Int          @id
  Contribution   Contribution @relation(fields: [contributionId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  targetUserkeys String[]
  chosenIndex    Int?

  @@map("contribution_trust_battles")
}

model ContributionScoreCheck {
  contributionId Int                 @id
  Contribution   Contribution        @relation(fields: [contributionId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  targetUserkey  String              @db.Citext
  answer         ContributionAnswer?

  @@map("contribution_score_checks")
}

model ContributionReviewCheck {
  contributionId Int                 @id
  Contribution   Contribution        @relation(fields: [contributionId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  reviewId       Int
  review         Review              @relation(fields: [reviewId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  answer         ContributionAnswer?

  @@map("contribution_review_checks")
}

model ContributionReviewVote {
  contributionId Int          @id
  Contribution   Contribution @relation(fields: [contributionId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  reviewId       Int
  review         Review       @relation(fields: [reviewId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  voteId         Int?
  vote           Vote?        @relation(fields: [voteId], references: [id], onUpdate: Cascade, onDelete: Cascade)

  @@map("contribution_review_votes")
}

model UserFcmToken {
  id               Int      @id @default(autoincrement())
  profileId        Int
  profile          Profile  @relation(fields: [profileId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  fcmToken         String
  deviceIdentifier String
  userAgent        String
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  @@unique([profileId, deviceIdentifier])
  @@index([profileId])
  @@map("user_fcm_tokens")
}

enum XpPointsHistoryItemType {
  REVIEW
  CONTRIBUTION
  INVITE_ACCEPTED
  VOUCH_DAY
  CLAIM
  EXTENSION_CHECK_IN
  CLAIM_REFERRAL
}

model XpPointsHistory {
  id        Int                     @id @default(autoincrement())
  userkey   String                  @db.Citext
  type      XpPointsHistoryItemType
  points    Int
  metadata  Json                    @db.JsonB
  createdAt DateTime

  @@index([userkey])
  @@index([createdAt])
  @@map("xp_points_history")
}

model Claim {
  twitterUserId String          @id
  initialAmount Int
  claimed       Boolean         @default(false)
  createdAt     DateTime        @default(now())
  claimedAt     DateTime?
  ClaimReferral ClaimReferral[]

  @@map("claims")
}

model ClaimReferral {
  id                       Int      @id @default(autoincrement())
  fromTwitterUserId        String
  ReferrerTwitterUserClaim Claim    @relation(fields: [fromTwitterUserId], references: [twitterUserId], onUpdate: Cascade, onDelete: Cascade)
  toTwitterUserId          String
  bonusAmountForSender     Int
  bonusAmountForReceiver   Int
  createdAt                DateTime @default(now())

  @@unique([fromTwitterUserId, toTwitterUserId])
  @@index([fromTwitterUserId])
  @@index([toTwitterUserId])
  @@map("claim_referrals")
}

model PrivyLogin {
  id              String   @id
  twitterUserId   String?  @unique
  connectedWallet String   @db.Citext
  embeddedWallet  String   @db.Citext
  smartWallet     String   @db.Citext
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([twitterUserId])
  @@index([connectedWallet])
  @@index([smartWallet])
  @@map("privy_logins")
}

model offchainScore {
  id        Int      @id @default(autoincrement())
  userkey   String   @db.Citext
  score     Int
  metadata  Json     @db.JsonB
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userkey])
  @@map("offchain_score")
}
